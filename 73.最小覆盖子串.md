> 题目描述：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。
>

eg:

```java
示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
说明：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。
```

> 思路描述：最简单的做法应该就是滑动窗口了，首先左右指针指向 S 的开头，然后右指针右移直到可以包含 T，这个时候记录下来子字符串的长度，然后左指针左移，判断当前子字符串是否包含 T，直到左指针左移到不包含 T 为止。然后右指针右移。
>
> 例如：` S = "ADOBECODEBANC", T = "ABC"`
>
> 首先左指针指向 A，右指针右移到 C，子串为 `ADOBEC`
>
> 然后左指针左移到 D，发现移除的是 T 中的字符 A，
>
> 右子串开始右移到下一个 A，子串为 `DOBECODEBA`
>
> 然后左指针左移，发现移除的是 D 没有影响，继续左移，直到子串变为 `CDEBA`
>
> .....
>
> 现在问题来了，过程我们知道了，那么怎么很好地去知道左右指针什么时候应该移动呢？
>
> 我们可以使用hash表去记录每个字母出现的次数，首先先把所有出现在 T 中的字符对应的值设为1；
>
> 然后遍历 S，count[s[r]] --，每次减 1，如果是 T 中的字母，减 1后会大于等于 0，所以 if (count[s[r]] >= 0) len ++，如果 len = t.size() 的话就说明现在左右指针中间的子字符串已经包含了整个 T；
>
> 接下来是左指针右移的过程，首先如果目前左指针指向的字符是 T 中的字符，那么应该大于等于0，否则小于 0 ，这点应该不用再解释了，所以我们可以让左指针指向的字符值加1，也就是 count[s[l]] ++; 如果这个值加一后还是不大于 0，那么说明移除之后子串中不包含整个 T 了，len 就减 1。
>
> 接下来是一样的过程，我们子串中已经包含的字符对应的数值要么等于 0，要么小于 0，但是刚刚移除掉的字符如果是 T 中的字符，它的值就会大于 0，下面的过程都一样了。
>
> 那么也许你们还有一个疑问？如果移除掉的字符在 T 内但是不必须呢？
>
> 比如 AABC，移除掉第一个 A 其实还是包含 ABC 的
>
> 我们看看，首先我们右指针移到 C 后，A 对应的值已经变成 -1 了，所以在左指针左移的过程中并不会触发 len -- 的操作。所以上述操作是完全可行的。

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> count;
        for (auto c : t) count[c] ++;
        int len = 0, minLen = s.size();
        string res;
        for (int l = 0, r = 0; r < s.size(); r ++) {
            count[s[r]] --;
            if (count[s[r]] >= 0) len ++;
            while (len == t.size()) {
                if (r - l + 1 <= minLen) {
                    minLen = r - l + 1;
                    res = s.substr(l, r - l + 1);
                }
                count[s[l]] ++;
                if (count[s[l]] > 0) len --;
                l ++;
            }
        }
        return res;
    }
};
```

