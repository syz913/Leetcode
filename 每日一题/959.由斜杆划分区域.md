### 题目描述

在由 1 x 1 方格组成的 N x N 网格 `grid` 中，每个 1 x 1 方块由 `/`、`\` 或空格构成。这些字符会将方块划分为一些共边的区域。

（请注意，反斜杠字符是转义的，因此 `\` 用 `"\\"` 表示。）。

返回区域的数目。

### 示例

**示例 1：**

```c++
输入：
[
  " /",
  "/ "
]
输出：2
解释：2x2 网格如下：
```

**示例 2：**

```c++
输入：
[
  " /",
  "  "
]
输出：1
解释：2x2 网格如下：
```

**示例 3：**

```c++
输入：
[
  "\\/",
  "/\\"
]
输出：4
解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）
2x2 网格如下：
```

**示例 4：**

```c++
输入：
[
  "/\\",
  "\\/"
]
输出：5
解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）
2x2 网格如下：
```

**示例 5：**

```c++
输入：
[
  "//",
  "/ "
]
输出：3
解释：2x2 网格如下：
```

### 思路

求区域数目，我们可以用并查集解，相信大家做了一个月的并查集，刷刷就能写出来个大概。重点是合并什么以及怎么合并？每个小方格里面可以是 `\` 、`/` 或者空格，我们需要注意一点，无论小方格里面是什么，一定可以把小方格 ”填满“ 的。对角线可以把小方格划分为 4 个小三角形。如果网格上的字符为 `/`，则右下角的两个三角形会与左上角的两个三角形分隔开；同理，如果字符为 `\`，则右上角的两个三角形会和左下角的两个三角形分隔开。

格子内部的情况：

- 如果为空格，则该格子对应的 444 个节点应当同属于同一区域，因此在它们之间各连接一条边；

- 如果为字符 `/`，则将左上角的两个格子连接一条边，并将右下角的两个格子连接一条边；

- 如果为字符 `\`，则将右上角的两个格子连接一条边，并将左下角的两个格子连接一条边。

不难观察到下面两点：

- 一个格子中最下方的三角形，必然和下面的格子（如果存在）中最上方的三角形连通；
- 一个格子中最右方的三角形，必然和右边的格子（如果存在）中最左方的三角形连通。

每个格子的 4 个节点按照上、右、下、左的顺序依次编号 0、1、2、3

```c++
class Solution {
public:
    // 路径压缩
    int find(vector<int>& f, int x) {
        if (f[x] == x) {
            return x;
        }
        int fa = find(f, f[x]);
        f[x] = fa;
        return fa;
    }

    void merge(vector<int>& f, int x, int y) {
        int fx = find(f, x);
        int fy = find(f, y);
        f[fx] = fy;
    }

    int regionsBySlashes(vector<string>& grid) {
        int n = grid.size();
        vector<int> f(n * n * 4);
        // 初始化每个节点的 father 是自己
        for (int i = 0; i < n * n * 4; i++) {
            f[i] = i;
        }
		// 遍历每一个小方格
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // idx 表示小方格的下标
                int idx = i * n + j;
                // 如果不是最后一行
                if (i < n - 1) {
                    // 合并当前小方格最下方的小三角形和下方的节点最上方的小三角形
                    int bottom = idx + n;
                    merge(f, idx * 4 + 2, bottom * 4);
                }
                // 如果不是最后一列
                if (j < n - 1) {
                   	// 合并当前小方格最右方的小三角形和右边节点最左边的小三角形
                    int right = idx + 1;
                    merge(f, idx * 4 + 1, right * 4 + 3);
                }
                // 如果当前位置为 /，合并左上方的小三角形和右下方的小三角形
                if (grid[i][j] == '/') {
                    merge(f, idx * 4, idx * 4 + 3);
                    merge(f, idx * 4 + 1, idx * 4 + 2);
                } else if (grid[i][j] == '\\') {						                                     // 如果当前位置为 \，合并左下方的小三角形和右上方的小三角形
                    merge(f, idx * 4, idx * 4 + 1);
                    merge(f, idx * 4 + 2, idx * 4 + 3);
                } else {
                    // 当前位置为空格，合并四个小三角形
                    merge(f, idx * 4, idx * 4 + 1);
                    merge(f, idx * 4 + 1, idx * 4 + 2);
                    merge(f, idx * 4 + 2, idx * 4 + 3);
                }
            }
        }

        unordered_set<int> fathers;
        for (int i = 0; i < n * n * 4; i++) {
            int fa = find(f, i);
            fathers.insert(fa);
        }
        return fathers.size();
    }
};
```
