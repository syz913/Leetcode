

### 题目描述

有 `n` 个气球，编号为`0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明:**

- 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100

### 示例

```C++
示例:

输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167

```

### 思路

最简单的做法就是递归所有可能的戳气球方法。

现在可以定义 `dp` 数组的含义：

**`dp[i][j] = x` 表示，戳破气球 `i` 和气球 `j` 之间（开区间，不包括 `i` 和 `j`）的所有气球，可以获得的最高分数为 `x`**。

那么根据这个定义，题目要求的结果就是 `dp[0][n+1]` 的值，而 base case 就是 `dp[i][j] = 0`，其中 `0 <= i <= n+1, j <= i+1`，因为这种情况下，开区间 `(i, j)` 中间根本没有气球可以戳。

气球 `i` 和气球 `j` 之间的所有气球都可能是最后被戳破的那一个，不防假设为 `k`。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：`i` 和 `j` 就是两个「状态」，最后戳破的那个气球 `k` 就是「选择」。

**根据刚才对 `dp` 数组的定义，如果最后一个戳破气球 `k`，`dp[i][j]` 的值应该为**：

```
dp[i][j] = dp[i][k] + dp[k][j] 
         + points[i]*points[k]*points[j]
```
那么，对于一组给定的 i 和 j，我们只要穷举 i < k < j 的所有气球 k，选择得分最高的作为 dp[i][j] 的值即可，这也就是状态转移方程：

```C++
// 最后戳破的气球是哪个？
for (int k = i + 1; k < j; k++) {
    // 择优做选择，使得 dp[i][j] 最大
    dp[i][j] = max(
        dp[i][j], 
        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
    );
}
```

```C++
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        // 添加两侧的虚拟气球
        int[] points = new int[n + 2];
        points[0] = points[n + 1] = 1;
        for (int i = 1; i <= n; i++) {
            points[i] = nums[i - 1];
        }
        // base case 已经都被初始化为 0
        int[][] dp = new int[n + 2][n + 2];
        // 开始状态转移
        // i 应该从下往上
        for (int i = n; i >= 0; i--) {
            // j 应该从左往右
            for (int j = i + 1; j < n + 2; j++) {
                // 最后戳破的气球是哪个？
                for (int k = i + 1; k < j; k++) {
                    // 择优做选择
                    dp[i][j] = Math.max(
                        dp[i][j], 
                        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
                    );
                }
            }
        }
        return dp[0][n + 1];
    }
}
```

