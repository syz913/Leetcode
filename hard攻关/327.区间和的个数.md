### 题目描述

给定一个整数数组 `nums`，返回区间和在 `[lower, upper]` 之间的个数，包含 `lower` 和 `upper`。
 区间和 `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)。

**说明:**
 最直观的算法复杂度是 $O(n^2)$ ，请在此基础上优化你的算法。

### 示例

**示例:**

```C++
输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3 
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。
```

### 思路

求区间和可以求

```C++

```

### 记录一道题

给定一个序列和w，要求把整个序列变成w，每一次操作选择一个l和r，使得序列区间l到r的值增加1。每一次操作的l都不相同且每一次操作的r都不相同，问有多少种方式可以把整个序列变成w，求结果对$10^9+7$取模的结果。（$1≤n≤10^5$）

#### Solution

转换成差分数组求解。先求这个序列最终需要增加的大小的序列的差分数组，如果差分数组有大于1或者小于−1则无解输出0，因为端点不能重复，而1代表这是区间增加的开始，−1代表这是区间增加的结束位置。还有一种无解的情况是有数比w大也是无解的。对于差分数组中的0，可以是1和−1的叠加。然后枚举差分数组中所有的−1位置假设当前位置是j（0处也要枚举，因为可能是叠加的状态），去选一个前面出现过的1假设这个1的位置是i，则区间[i,j−1]被选择了，选的情况很显然就是前面1的个数，前面1的个数实际上就是转换后的数组，因为差分数组再前缀和就是原来的数组，然后将所有枚举的情况累乘即可。~~好像本题是一个套路题，但原题暂时没有办法找到。~~

```C++
#include <bits/stdc++.h>
using namespace std;
int a[100005], b[100005];
const int64_t MOD = 1e9 + 7;
int main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  int n, w; cin >> n >> w;
  bool ok = true;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    a[i] = w - a[i];
    b[i] = a[i] - a[i - 1];
    if (a[i] < 0 || b[i] < -1 || b[i] > 1) {
      ok = false;
    }
  }
  b[n + 1] = -a[n];
  if (b[n + 1] < -1 || b[n + 1] > 1) {
    ok = false;
  }
  if (!ok) {
    cout << "0\n";
    return 0;
  }
  int64_t ans = 1;
  for (int i = 1; i <= n + 1; i++) {
    if (b[i] == 0 || b[i] == -1) {
      ans = (ans * (a[i] + 1)) % MOD;
    }
  }
  cout << ans << '\n';
}
```

首先区间 [i, j - 1] 的值都增加 1，如上面的处理，其实就是差分数组 f[i] 减 1，f[j] 加 1，

我们注意到上面构建的差分数组的和为 0，也就是说一定有相同数目的 1 和 -1，因为每个 l 和 r 只能出现一次，所以我们一次操作必须把首尾的元素变成 0，所以我们遍历到 -1 的话就要寻找前面的 1，这样我们才能把 1 变成 0，并且每个 -1 都可以有自己对应的 1，并且由于差分数组的前缀和就是当前元素，所以在前面的 -1 都匹配到自己的 1 之后，当前的 -1 可以匹配到的 1 的个数就是 a[i] + 1

而对于 0，把 0 看着 1 和 -1 的组合，做法和前面说的一样，那就可以了。