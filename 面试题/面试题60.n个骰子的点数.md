> 题目描述：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
>

eg:

```java
示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```
>思路描述，n 枚骰子掷出的点数的范围是 [n, 6*n]，也就是最后数组的长度为 5n + 1，因为每个骰子掷出每个数字的概率都是 1/6，所以对于 n 枚骰子，每次掷出的数字组合的概率都为 (1/6)^n。
>
>也就是说如果和为 s 的组合有 k 种，那么和为 s 的概率为 k*(1/6)^n
>
>我们这里采用动态规划的思想进行处理，假设我们我们投掷完 n 枚骰子后总点数为 j，使用 dp\[n][j] 表示投完 n 枚骰子后总点数为 j 的出现次数，那么我们考虑递推关系式，投第 n 枚骰子可以由投第 n-1 枚骰子转换而来，也就是如果投第 n-1 枚骰子后总点数为 j-i (1 ≤ i ≤ 6)，那么第 n 次掷出 i 即可满足条件。

则 $dp[n][j] = \sum_{i=1}^6dp[n-1][j-i]$

```C++
class Solution {
public:
    vector<double> twoSum(int n) {
        //n <= 11
        vector<vector<double>>dp(n + 1, vector<double>(6*n + 1, 0));
        vector<double> ans;
        for(int i = 1; i <= n; i ++){
            for(int j = i; j <= 6*i; j ++){
                if(i == 1) {
                    dp[i][j] = 1;
                    continue;
                }
                for(int k = 1; k <= 6; k ++){
                    if(j - k >= i - 1) dp[i][j] += dp[i - 1][j - k];
                }
            }
        }
        for(int i = n; i <= 6*n; i ++){
            ans.push_back(dp[n][i] * pow(1.0/6, n));
        }
        return ans;
    }
};
```

> 正如我前几篇题解中所说的，动态规划一般都是可以进行空间优化的。我们看一下每一行其实使用了上一行的至多 6 个值，所以我们可以使用一个长度为 6 的数组去存储一下这六个值。
>
> 当然啦，我也不喜欢去再存储一下，太麻烦了，所以就和扔鸡蛋那个问题一样把第二个循环倒一下就可以了。

```C++
class Solution {
public:
    vector<double> twoSum(int n) {
        //n <= 11
        vector<double>dp(6*n + 1, 0);
        vector<double> ans;
        for(int i = 1; i <= n; i ++){
            for(int j = 6*i; j >= i; j --){
                dp[j] = 0;
                if(i == 1) {
                    dp[j] = 1;
                    continue;
                }
                for(int k = 1; k <= 6; k ++){
                    //需要保证硬币总和得大于等于硬币数
                    if(j - k >= i - 1) dp[j] += dp[j - k];
                }
            }
        }
        for(int i = n; i <= 6*n; i ++){
            ans.push_back(dp[i] * pow(1.0/6, n));
        }
        return ans;
    }
};
```

> 下面写出一种错误的思路，我刚开始是这么想的，但是感觉有些价值，也就写出来大家看一下。
>
> 每枚骰子掷出每个点数的概率都为 1/6 。
>
> n 枚骰子掷出的点数的范围是 [n, 6*n]，也就是最后数组的长度为 5n + 1
>
> 其中掷出点数 i 的概率相当于从 i 个数中插入 n - 1 个分隔把这 i 个数分成 n 份，每份对应着每个骰子的点数。
>
> 举个例子，点数为 8，n = 3
>
> 1 1 1 1 1 1 1 1
>
> 向中间插入两个分隔线
>
> ​			  |        |
> ​			1 1 1 |  1 1 |  1 1 1
>  ​					 |        |
>
> 那么分隔线的插法的总数就相当于 n 个骰子投出数字组合的总数，这是标准的排列组合思想，又因为每个骰子掷出每个数字的概率都是 1/6，即每种数字组合的概率都是 (1/6)^n。

总的组合数为 $C_{i - 1}^{n-1}$

> 那么每个 i 对应的概率就是组合数乘以概率，但是这种思路忽略了两个间隔不能超过 6！

```C++
class Solution {
    int cal(int n){
        if(n == 0 || n == 1) return 1;
        return n * cal(n - 1);
    }
public:
    vector<double> twoSum(int n) {
        vector<double> nums;
        for(int i = n; i <= 6*n; i ++){
            double num = cal(i - 1)/(cal(n - 1) * cal(i - n));
            double num2 = pow(1.0/6, n);
            nums.push_back(num * num2);
        }
        return nums;
    }
};
```
