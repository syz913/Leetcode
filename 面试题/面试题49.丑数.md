> 题目描述：我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

eg:

```java
示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

> 思路描述：这个就很清晰了，一个数字可以拆分成若干因子之积，那么我们也可以使用不同因子去构造这个数。首先第一个数是  1，然后是
>
> 2\*1	2\*2	3\*1	5\*1 ......
>
> 我们可以看出来每次都是前面某个数字乘以 2 或者 3 或者 5，取其中的最小者。
>
> 我们定义三个指针 p2、p3、p5 分别指向要乘以 2、3、5 的数字。dp[i] 表示第 i 个丑数。
>
> 那么 dp[p2] * 2、dp[p3] * 3 和 dp[p5] * 5 中的最小值就是下一个丑数。
>
> 为什么呢？因为首先这三个指针之前的数字都是进行比较过加入 dp 中了，并且这三个指针之后的数字一定比当前数字要大，不符合题意，所以下一个丑数一定在三个数字之间。
>
> 比如说是 dp[p2] * 2，那么 p2 指向 p2 + 1，也就是只有在加入 dp 之后才会前移一步。

```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n, 0);
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for(int i = 1; i < n; i ++){
            dp[i] = min(min(dp[p2]*2, dp[p3]*3), dp[p5]*5);
            if(dp[i] == dp[p2]*2) p2++;
            if(dp[i] == dp[p3]*3) p3++;
            if(dp[i] == dp[p5]*5) p5++;
        }
        return dp[n - 1];
    }
};
```
