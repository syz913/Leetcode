> 题目描述：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
>

eg:

```java
示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

> 思路描述：之所以一个数字可能有不同的翻译情况，是因为比如说 12 可以分开翻译或者合在一起翻译。
>
> 我们可以定义数组 dp[i] 表示前 i + 1 位翻译的方法数，对于 12258 来说 dp[0] 代表 1 的翻译数，dp[1] 代表 12 的翻译数，dp[2] 代表 122 的翻译数....
>
> 那么每往后面加一位数字，如果该数字不可以和前一位数字合在一起翻译(比如前一位为 3，该数字为 5)，那么 dp[i] = dp[i - 1]，因为最后一个数字只能单独翻译，并不影响前面数字翻译的方法数。
>
> 如果该数字可以和前一位数字合在一起翻译，那么可以选择是否和前一位合在一起翻译，如果前一位不为0，不合在一起的方法数为 dp[i - 1]，合在一起翻译的方法数为 dp[i - 2]，则 dp[i] = dp[i - 1] + dp[i - 2]。
>
> 如果前一位为 0 的话，dp[i] = dp[i - 1]。
>
> 我们递推关系式就这样得出来了。动态规划的题目其实就是需要一步步去分析的。
>
> 我们需要一个数组去存储数字每个位的值。但是并不需要去使用数组存 dp 的值，类似于斐波那契数列，用两个变量存储一下就好了。

```C++
class Solution {
public:
    int translateNum(int num) {
        if(num < 10) return 1;
        vector<int> nums;
        while(num){
            nums.push_back(num % 10);
            num /= 10;
        }
        reverse(nums.begin(), nums.end());
        int ans = 0, num1 = 1, num2 = 1;
        for(int i = 1; i < nums.size(); i ++){
            if(nums[i - 1] == 0 || nums[i - 1] * 10 + nums[i] > 25){
                ans = num1;   
            }else{
                ans = num1 + num2;
            }
            num2 = num1;
            num1 = ans;
        }
        return ans;
    }
};
```
