### 题目描述

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 < T2 < … < Ti , Ti > Ti+1 > … > TK (1 <= i <= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

#### 输入描述

>```c++
>输入的第一行是一个整数N（2 <= N <= 100），表示同学的总数。
>第一行有n个整数，用空格分隔，第i个整数Ti（130 <= Ti <= 230）是第i位同学的身高（厘米）。
>```

#### 输出描述

> ```c++
> 可能包括多组测试数据，对于每组数据，
> 输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
> ```

### 示例

输入：

```c++
8
186 186 150 200 160 130 197 220
```

输出：

```cpp
4
```

### 思路

其实也就是求出每位同学前后的最长递增/减子序列，求最长递增子序列的话我们可以使用动态规划 dp[i] 是以 i 结尾的最长递增子序列长度，那么 

$dp[i]=max(dp[j])+1,其中 0≤j<i 且 num[j]<num[i]$

```c++
#include<iostream>
using namespace std;
const int maxn=100;
int a1[maxn],a2[maxn],dp1[maxn],dp2[maxn];
int main(){
    int n;
    while(cin>>n){
        for(int i=0;i<n;i++){
            cin>>a1[i];
            a2[n-1-i]=a1[i];
        }
        for(int i=0;i<n;i++){
            dp1[i]=1;dp2[i]=1;
            for(int j=0;j<i;j++){
                if(a1[j]<a1[i])
                    dp1[i]=max(dp1[i],dp1[j]+1);
                if(a2[j]<a2[i])
                    dp2[i]=max(dp2[i],dp2[j]+1);
            }
        }
        int res=0;
        for(int i=0;i<n;i++){
            dp1[i]+=dp2[n-1-i];
            res=max(res,dp1[i]);
        }
        cout<<n-res+1<<endl;
    }
    return 0;
} 
```

