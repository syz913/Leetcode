### 题目描述

辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。 为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。 医师把他带到个到处都是草药的山洞里对他说： “孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。 我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？

#### 输入描述

>```c++
>输入的第一行有两个整数T（1 <= T <= 1000）和M（1 <= M <= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。
>接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。
>```

#### 输出描述

> ```c++
> 可能有多组测试数据，对于每组数据，
> 输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
> ```

### 示例

输入：

```c++
70 3
71 100
69 1
1 2
```

输出：

```cpp
3
```

### 思路

这个和 [点菜问题](https://blog.nowcoder.net/n/b2a5c821bd014b918262d9b668d51391) 一样，也是 0-1 背包问题，这里就不进行赘述了，用 dp\[i][j] 表示限时 j 采前 i 种药的最大总价值，那最后求出来 dp\[M][T] 就好了

- 不采第 i 种药：$dp[i][j] = dp[i-1][j]$
- 采第 i 种药：$dp[i][j] = dp[i-1][j-T_i]+V_i$

因为前面已经说过如果进行空间复杂度的优化，这里我就直接写出优化后的版本了。

```c++
#include<iostream>
#include<vector>

using namespace std;

int main(){
    int T, M;
    while(cin >> T >> M){
        vector<pair<int, int>> herbs;
        int time, value;
        for(int i = 0; i < M; i ++){
            cin >> time >> value;
            herbs.emplace_back(time, value);
        }
        vector<int> dp(T + 1, 0);
        for(int i = 0; i < M; i ++){
            for(int j = T; j >= herbs[i].first; j --)
                dp[j] = max(dp[j], dp[j - herbs[i].first] + herbs[i].second);
        }
        cout << dp[T] << endl;
    }
    return 0;
}
```

