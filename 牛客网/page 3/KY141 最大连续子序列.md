### 题目描述

 给定K个整数的序列{ N1, N2, ..., NK }，其任意连续子序列可表示为{ Ni, Ni+1, ..., Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。

#### 输入描述　　

> ```c++
> 测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K< 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。
> ```

#### 输出描述

> ```c++
> 对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。
> ```

### 示例

输入：

```c++
6
-2 11 -4 13 -5 -2
10
-10 1 2 3 4 -5 -23 3 7 -21
6
5 -8 3 2 5 0
1
10
3
-1 -5 -2
3
-1 0 -2
0
```

输出：

```c++
20 11 13
10 1 4
10 3 5
10 10 10
0 -1 -2
0 0 0
```

### 思路

动态规划题目，我们用 dp[i] 表示以 nums[i] 结尾的连续子序列的最大元素和，则：

- dp[i] < 0，dp[i + 1] = nums[i + 1]
- dp[i] > 0，dp[i + 1] = dp[i] + nums[i + 1]

因为要输出首尾元素，其中尾部元素我们已经知道了，首部元素遍历一下就出来了，从 i 往前遍历到 dp[i] < 0。

```c++
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int main(){
    int K;
    while(cin >> K && K){
        vector<int> nums(K, 0), dp(K, 0);
        int sum = -1, head = 0, tail = -1;
        for(int i = 0; i < K; i ++){
            cin >> nums[i];
            if(i > 0) 
                dp[i] = max(nums[i], nums[i] + dp[i - 1]);
            else dp[i] = nums[i];
            if(dp[i] > sum){
                sum = dp[i]; tail = i;
            }
        }
        // 所以 tail 没有改变，说明所有元素小于 0
        if(tail == -1) cout << 0 << " " << nums[0] << " " << nums.back() << endl;
        else {
            // 寻找首部元素
            for(int i = tail; i >= 0 ; i--){
                if(dp[i] < 0){
                    head = i + 1; break;
                }
            }
            cout << sum << " " << nums[head] << " " << nums[tail] << endl;
        }
    }
}
```

