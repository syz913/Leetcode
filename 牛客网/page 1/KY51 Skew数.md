### 题目描述

在 skew binary 表示中，第 k 位的值 x[k] 表示 x[k]×(2^(k+1)-1)。每个位上的可能数字是 0 或 1，最后面一个非零位可以是 2，例如，10120(skew) = 1×(2^5-1) + 0×(2^4-1) + 1×(2^3-1) + 2×(2^2-1) + 0×(2^1-1) = 31 + 0 + 7 + 6 + 0 = 44。前十个 skew 数是 0、1、2、10、11、12、20、100、101、以及 102。

#### 输入描述

>```c++
>输入包含一行或多行，每行包含一个整数n。如果 n = 0 表示输入结束，否则n是一个skew数
>    ```

#### 输出描述

>```c++
>可能有多组测试数据，对于每一个输入，
>输出它的十进制表示。转换成十进制后， n 不超过 231-1 = 2147483647
>```

### 示例

输入：

```c++
10120
200000000000000000000000000000
10
1000000000000000000000000000000
11
100
11111000001110000101101102000
0
```

输出：

```c++
44
2147483646
3
2147483647
4
7
1041110737
```

### 思路

题干无力吐槽，借用一下讨论中的更正：

在 skew binary 表示中，第 k 位的值 x[k] 表示 x[k]×(2^(k+1)-1)。每个位上的可能数字是 0 或 1，最后面一个非零位可以是 2，例如，10120(skew) = 1×(2^5-1) + 0×(2^4-1) + 1×(2^3-1) + 2×(2^2-1) + 0×(2^1-1) = 31 + 0 + 7 + 6 + 0 = 44。前十个 skew 数是 0、1、2、10、11、12、20、100、101、以及 102。

那就很简单了。

```c++
#include<iostream>
#include<cmath>

using namespace std;

int main(){
    string num;
    while(cin >> num){
        if(num == "0") break;
        int n = num.size(), sum = 0;
        for(int i = 0; i < n; i ++){
            if(num[i] != '0')
                sum += (num[i] - '0') * (pow(2, n - i) - 1);
        }
        cout << sum << endl;
    }
}
```

