### 题目描述

  1 
  	   / \
   	 2  3
	   / \ / \
	  4 5 6 7
     /\ /\ /\ /\
 如上图所示，由正整数 1, 2, 3, ...组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从5到根结点的路径是（5, 2, 1），从4到根结点的路径是（4, 2, 1），从根结点1到根结点的路径上只包含一个结点1，因此路径就是（1）。对于两个结点x和y，假设他们到根结点的路径分别是（x1, x2, ... ,1）和（y1, y2,...,1），那么必然存在两个正整数i和j，使得从xi 和yj 开始，有xi = yj，xi + 1 = yj + 1，xi + 2 = yj + 2，...
 现在的问题就是，给定x和y，要求他们的公共父节点，即xi（也就是 yj）。

#### 输入描述

> ```c++
> 输入包含多组数据，每组数据包含两个正整数x和y（1≤x, y≤2^31-1）。
> ```

#### 输出描述

> ```c++
> 对应每一组数据，输出一个正整数xi，即它们的首个公共父节点。
> ```

### 示例

输入：

```c++
10 4
```

输出：

```c++
2
```

### 思路

如果是普通的二叉树，求公共父节点的话，就是遍历某个根节点的左右子树，看看这两个节点是否在一棵子树上，在的话就继续遍历子树，不在的话就直接返回根节点。

而这道题，很容易看出来一个节点 i 的父节点就是 i/2，那就很简单了，不断除以 2 直到相等就好了。

```c++
#include<iostream>

using namespace std;

int main(){
    int x, y;
    while(cin >> x >> y){
        while(x != y){
            if(x > y) x /= 2;
            else y /= 2;
        }
        cout << x << endl;
    }
    return 0;
}
```

